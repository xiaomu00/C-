#include<iostream>
using namespace std;

////////////////////////////////////////////////////////////////////
////语法
//class Base
//{};

////子类   //父类
//class D :public Base
//{};


////////////////////////////////////////////////////////////////////
//////功能
//class Base
//{
//public:
//	void fun()
//	{
//		cout << "Base::fun()" << endl;
//	}
//};
//
//
//class D :public Base
//{
//public:
//	void show()
//	{
//		cout << "D::show()" << endl;
//	}
//};
//
//
//int main()
//{
//	D d;
//	d.show();//既可以访问自身成员
//	d.fun();//也可以访问父类成员，可以继承父类的一切，除去构造函数和析构函数
//	return 0;
//}

//////////////////////////////////////////////////////////////////////
//////大小
//class Base
//{
//private:
//	int b;
//};
//
//class D :public Base
//{
//private:
//	int d;
//};
//
//int main()
//{
//	cout << sizeof(D) << endl;//大小等于自己成员的大小加上父类成员的大小
//	return 0;
//}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////公有继承、私有继承、保护继承的区别
//class Base
//{
//public:
//	void fun()
//	{ cout << "Base::fun()" << endl; }
//protected:
//	void list()
//	{cout << "Base::list()" << endl;}
//private:
//	void print()
//	{cout << "Base::print()" << endl;}
//private:
//	int b;
//};
//
//class D :public Base  //公有继承
//{
//	void d()
//	{
//		fun();
//		list();
//		//print();//编译不通过,只能访问公有成员和保护成员
//
//	}
//};
//
//class S :protected Base
//{
//	void s()
//	{
//		fun();
//		list();
//		//print();//编译不通过,只能访问公有成员和保护成员
//	}	
//};
//
//class M :private Base
//{
//	void m()
//	{
//		fun();
//		list();
//		//print();//编译不通过,只能访问公有成员和保护成员
//	}
//};
//int main()
//{
//
//	////以对象的角度
//
//	D d;
//	d.fun();
//	/*d.list();
//	d.print();*/ //  编译不通过，能将父类的信息继承，但是对象只能访问公有数据
//
//	S s;
//	/*s.fun();
//	s.list();
//	s.print();*///都编译不通过，保护继承，会将父类的所有信息继承过来，但全都变为保护属性，对象不能访问
//
//	M m;
//	/*m.fun();
//	m.list();
//	m.print();*///都编译不通过，私有继承，会将父类的所有信息继承过来，但全都变为私有属性，对象不能访问
//	return 0;
//}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
////同名隐藏
class A
{
public:
	void fun()
	{
		cout << "A::fun()" << endl;
	}
	void fun(int a)
	{
		cout << "A::fun(int a)" << endl;
	}
	void fun(int a,int b)
	{
		cout << "A::fun(int a,int b)" << endl;
	}
	
private:
	int b;
};



class B :public A  //公有继承
{
};

class C :public A
{
public:
	void fun()
	{
		cout << "C::fun()" << endl;
	}
};



class D :public A
{
public:
	void fun(int a,int b,int c)
	{
		cout << "D::fun()" << endl;
	}
};

int main()
{
	B b;
	cout << "B:" << endl;
	b.fun();
	b.fun(1);
	b.fun(1,2);  //派生类可以访问基类函数成员
	cout << endl << endl;


	C c;
	cout << "C:" << endl;
	c.fun();//，当派生类中有和基类同名的函数时，可以看出，调用的是派生类自己的成员函数
	//c.fun(1);   //编译不通过，说明当派生类中有和基类同名的函数时，会覆盖基类中的同名函数和重载函数，称为“同名隐藏”
	c.A:: fun(1);//如果要访问，必须加上作用域运算符

	D d;
	cout << "D:" << endl;
	//d.fun();
	//d.fun(1);
	//d.fun(1,2);//编译不通过，说明不管形参列表相不相同，只要是函数名相同，就会形成同名隐藏
	d.fun(1,2,3);

	return 0;
}
